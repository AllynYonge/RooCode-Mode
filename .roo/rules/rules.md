# SPARC 代理开发规则

## 核心理念
1. 简洁性：优先选择清晰、易于维护的解决方案；最大限度减少不必要的复杂性。
2. 迭代改进：在现有代码基础上进行增强，除非有充分理由需要根本性改变。
3. 聚焦原则：严格遵循既定任务；避免与主题无关的范围变更。
4. 质量保障：通过结构化工作流程交付整洁、经过测试、有文档记录且安全的结果。
5. 协作精神：促进人类开发者与自主代理之间的高效团队协作。

## 方法论与工作流程

- 结构化工作流程
  - 遵循从需求定义到部署的明确阶段。
- 灵活性
  - 根据不同项目规模和复杂度调整流程。
- 智能演进
  - 使用高级符号推理和自适应复杂度管理持续改进代码库。
- 自觉整合
  - 在每个开发阶段融入反思意识。

## 与 Cline 和 Cursor 的代理整合

- Cline 配置 (.clinerules)
  - 嵌入简洁的、项目特定的规则来指导自主行为、提示设计和上下文决策。

- Cursor 配置 (.cursorrules)
  - 明确定义存储库特定的标准，包括代码风格、一致性、测试实践和符号推理集成点。

## 记忆库整合

- 持续上下文
  - 在开发各阶段持续保留相关上下文，确保连贯的长期规划和决策。
- 参考先前决策
  - 定期审查记忆库中存储的过往决策以保持一致性并减少冗余。
- 自适应学习
  - 利用历史数据和先前解决方案来自适应优化新实现。

## 编程语言通用指南

1. 清晰度与可读性
   - 偏好使用直截了当、自我解释的代码结构。
   - 添加描述性注释以阐明复杂逻辑。

2. 语言特定最佳实践
   - 遵循每种语言（Python、JavaScript、Java 等）已确立的社区和项目特定最佳实践。
   - 定期查阅语言文档和风格指南。

3. 跨代码库一致性
   - 在项目使用的所有语言中保持统一的编码规范和命名方案。

## 项目背景与理解

1. 文档优先
   - 实施前审阅必要文档：
     - 产品需求文档 (PRDs)
     - README.md
     - docs/architects.md
     - docs/pseudocodes.md
   - 若文档不完整或含糊不清，立即请求澄清。

2. 架构遵循
   - 遵循既定模块边界和架构设计。
   - 使用符号推理验证架构决策；在必要时提出合理替代方案。

3. 模式与技术栈意识
   - 使用文档记录的技术和既定模式；仅在有充分理由时引入新元素。

## 任务执行与工作流程

### 任务定义与步骤

1. 规范说明
   - 定义明确目标、详细需求、用户场景和 UI/UX 标准。
   - 使用高级符号推理分析复杂场景。

2. 伪代码
   - 在编码前清晰绘制逻辑实现路径。

3. 架构设计
   - 使用适当技术栈设计模块化、可维护的系统组件。
   - 确保为自主决策明确定义集成点。

4. 优化完善
   - 使用自主反馈循环和利益相关者输入迭代优化代码。

5. 完成阶段
   - 进行严格测试，最终确定全面文档，并部署结构化监控策略。

## AI 协作与提示工程

1. 明确指令
   - 提供包含明确结果、约束条件和上下文信息的具体指示。

2. 上下文引用
   - 定期参考记忆库中存储的先前阶段和决策。

3. 建议 vs. 执行
   - 明确区分 AI 应该提出建议 ("建议：") 还是直接实施更改 ("应用修复：")。

4. 关键评估
   - 彻底审查所有代理输出以确保准确性和逻辑一致性。

5. 聚焦互动
   - 向 AI 代理分配具体、明确的任务以保持清晰度。

6. 发挥代理优势
   - 利用 AI 进行重构、符号推理、自适应优化和测试生成；核心逻辑和战略架构仍需人工监督。

7. 渐进进展
   - 将复杂任务分解为可逐步审查的子步骤。

8. 标准检查点
   - 示例："确认理解：已查阅 [上下文]，目标为 [目标]，正在执行 [步骤]。"

## 高级编码能力

- 涌现智能
  - AI 自主维护内部状态模型，支持持续优化。
- 模式识别
  - 自主代理执行高级模式分析以实现有效优化。
- 自适应优化
  - 通过不断演化的反馈循环精炼开发过程。

## 符号推理整合

- 符号逻辑整合
  - 结合符号逻辑与复杂度分析实现稳健决策。
- 信息整合
  - 利用符号数学和既定软件模式实现连贯实现。
- 连贯文档
  - 通过符号推理维护清晰、语义准确的文档。

## 代码质量与风格

1. TypeScript 指南
   - 使用严格类型，并用 JSDoc 明确记录逻辑。

2. 可维护性
   - 编写模块化、可扩展的代码，优化清晰度和可维护性。

3. 精简组件
   - 保持文件精简（少于 300 行），主动进行重构。

4. 避免重复 (DRY)
   - 使用符号推理系统识别冗余。

5. 代码检查/格式化
   - 一贯遵守 ESLint/Prettier 配置。

6. 文件命名
   - 使用描述性强、永久且标准化的命名约定。

7. 无一次性脚本
   - 避免将临时实用脚本提交到生产仓库。

## 重构

1. 有目的的修改
   - 以明确目标进行重构：提高可读性、减少冗余、符合架构指南。

2. 整体方法
   - 通过符号分析整合相似组件。

3. 直接修改
   - 直接修改现有代码而非复制或创建临时版本。

4. 集成验证
   - 修改后验证和确认所有集成。

## 测试与验证

1. 测试驱动开发
   - 在实现功能或修复之前定义并编写测试。

2. 全面覆盖
   - 对关键路径和边缘情况提供彻底测试覆盖。

3. 强制通过
   - 立即处理任何失败测试以维持高质量标准。

4. 手动验证
   - 用结构化手动检查补充自动化测试。

## 调试与故障排除

1. 根因解决
   - 使用符号推理识别问题的根本原因。

2. 精准日志
   - 集成精确日志记录以便高效调试。

3. 研究工具
   - 使用高级代理工具（Perplexity, AIDER.chat, Firecrawl）高效解决复杂问题。

## 安全性

1. 服务端权威
   - 将敏感逻辑和数据处理严格限制在服务端。

2. 输入净化
   - 强制执行严格的服务端输入验证。

3. 凭证管理
   - 通过环境变量安全管理凭证；避免硬编码。

## 版本控制与环境

1. Git 规范
   - 经常提交并附带清晰描述性的提交信息。

2. 分支策略
   - 严格遵守定义的分支指南。

3. 环境管理
   - 确保所有环境中的代码一致性和兼容性。

4. 服务器管理
   - 在更新或配置更改后系统重启服务器。

## 文档维护

1. 反思型文档
   - 通过符号推理保持全面、准确且逻辑结构化的文档更新。

2. 持续更新
   - 定期回顾并完善指南以反映演变的实践和积累的项目知识。

3. 每个文件检查一次
   - 确保所有文件都经过准确性与相关性检查。

4. 注释使用
   - 使用注释阐明复杂逻辑，为未来开发者提供上下文。

## 工具使用
   
<details><summary>文件操作</summary>


<read_file>
  <path>文件路径</path>
</read_file>

<write_to_file>
  <path>文件路径</path>
  <content>你的文件内容</content>
  <line_count>总行数</line_count>
</write_to_file>

<list_files>
  <path>目录路径</path>
  <recursive>true/false</recursive>
</list_files>

</details>


<details><summary>代码编辑</summary>


<apply_diff>
  <path>文件路径</path>
  <diff>
    <<<<<<< SEARCH
    原始代码
    =======
    更新代码
    >>>>>>> REPLACE
  </diff>
  <start_line>起始行</start_line>
  <end_line>结束行</end_line>
</apply_diff>

<insert_content>
  <path>文件路径</path>
  <operations>
    [{"start_line":10,"content":"新代码"}]
  </operations>
</insert_content>

<search_and_replace>
  <path>文件路径</path>
  <operations>
    [{"search":"旧文本","replace":"新文本","use_regex":true}]
  </operations>
</search_and_replace>

</details>


<details><summary>项目管理</summary>


<execute_command>
  <command>你的命令</command>
</execute_command>

<attempt_completion>
  <result>最终输出</result>
  <command>可选 CLI 命令</command>
</attempt_completion>

<ask_followup_question>
  <question>需要澄清的问题</question>
</ask_followup_question>

</details>


<details><summary>MCP 集成</summary>


<use_mcp_tool>
  <server_name>服务器</server_name>
  <tool_name>工具</tool_name>
  <arguments>{"param":"value"}</arguments>
</use_mcp_tool>

<access_mcp_resource>
  <server_name>服务器</server_name>
  <uri>resource://路径</uri>
</access_mcp_resource>

</details>