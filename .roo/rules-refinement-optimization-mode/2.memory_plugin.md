你可以维护和使用"记忆库（Memory Bank）"以确保对项目背景的了解和长期理解，请严格遵从`## 记忆库 (Memory Bank) 协议`

## 记忆库 (Memory Bank) 协议

本协议详细规定了您与记忆库交互的所有规则。

*   **状态前缀：** 您的每一个回复都**必须**以当前记忆库的状态作为前缀：`[MEMORY BANK: ACTIVE]` 或 `[MEMORY BANK: INACTIVE]`。
*   **核心功能：** 记忆库使您能够访问项目的历史决策、当前状态和核心背景，从而做出更具信息量的架构决策。

### 记忆库初始化检查与使用

本节说明如何检查记忆库状态并根据其存在与否采取行动。

<thinking>
我将执行以下步骤来检查并确定记忆库的使用状态：
1.  检查 `docs/memory-back/` 目录是否存在。
2.  如果存在，则读取其内容并激活记忆库。
3.  如果不存在，则通知用户并通过“SPARC模式”进行外部初始化建议，然后以非活动状态继续。
</thinking>

#### 检查记忆库存在性
<thinking>首先，我需要检查 `docs/memory-back/` 目录是否存在于当前工作环境中。</thinking>
<list_files>
    <path>.</path>
    <recursive>false</recursive>
</list_files>

#### 记忆库存在
**情况一：如果 `docs/memory-back/` 目录存在 (记忆库已初始化)**
<thinking>
记忆库目录存在。我将按顺序读取所有核心记忆库文件以加载上下文。
</thinking>
1.  **读取记忆库文件：**
    *   读取 `docs/prd/productContext.md`。
    *   读取 `docs/memory-back/activeContext.md`。
    *   读取 `docs/memory-back/systemPatterns.md`。
    *   读取 `docs/memory-back/decisionLog.md`。
    *   读取 `docs/memory-back/progress.md`。
2.  **设置状态并通知：** 将状态设置为 `[MEMORY BANK: ACTIVE]` 并在您的响应开头使用此前缀。告知用户：“记忆库已加载并激活。”
3.  **继续任务：** 使用已加载的记忆库上下文继续当前任务。如果没有明确任务，请使用 `ask_followup_question` 工具与用户确认下一步操作。

#### 记忆库不存在
**情况二：如果 `docs/memory-back/` 目录不存在 (记忆库未初始化)**
<thinking>
`docs/memory-back/` 目录未找到。我不能自行创建它。我需要告知用户，建议通过SPARC模式初始化，并以INACTIVE状态继续。
</thinking>
1.  **告知用户并建议：**
    回复用户：“未找到记忆库。为了维护项目上下文、跟踪决策和进展，建议通过 **SPARC 模式** (或您指定的外部机制) 来初始化记忆库。在记忆库初始化之前，我将以非活动模式运行，无法持久化本次会话的上下文。”
2.  **设置状态：** 将状态设置为 `[MEMORY BANK: INACTIVE]` 并在您的响应开头使用此前缀。
3.  **继续任务：** 在没有记忆库功能的情况下继续当前任务。如果没有明确任务，请使用 `ask_followup_question` 工具。


### 记忆库文件更新规则

在交互过程中，当发生值得记录的事件时，您需要根据以下规则更新记忆库中的文件。

*   **`docs/memory-back/progress.md`**
    *   **用途:** 使用任务列表格式记录项目的进展，包括已完成的任务、当前正在进行的任务以及规划中的下一步（待办事项）。
    *   **初始内容模板:**
        ```markdown
        # 项目进展日志

        ## ✅ 已完成任务 (Completed Tasks)
        * [YYYY-MM-DD HH:MM:SS] - 记忆库初始化完成。

        ## ⏳ 当前任务 (Current Tasks)
        * (等待用户输入第一个具体任务)

        ## ➡️ 下一步规划 (Next Steps / Backlog)
        * (根据用户输入和项目阶段规划后续任务)
        ```
    *   **更新协议 (Update Protocol):**
        *   **触发条件:** 当一个任务的状态发生改变时（例如：从“待办”到“进行中”，或从“进行中”到“已完成”）或有新任务，在`## ➡️ 下一步规划`中新增一条。
        *   **操作:**
            <thinking>
            任务进展状态已更新。我需要修改 `progress.md`。这通常涉及将一个任务项从一个标题下移动到另一个标题下（例如，从`## ⏳ 当前任务`移动到`## ✅ 已完成任务`），并更新其时间戳。此操作最适合使用 `apply_diff` 来精确地删除旧行并添加新行。同时，我必须更新文件顶部的 `_最后更新: ...` 时间戳。
            </thinking>
        *   **更新方式:** 使用 `apply_diff` 在不同章节之间**移动和修改**任务项。例如，要将一个任务标记为完成：
            1.  在`## ⏳ 当前任务`下找到并**移除**该任务行。
            2.  在`## ✅ 已完成任务`下**添加**该任务行，并更新其时间戳。
            ```markdown
            * [YYYY-MM-DD HH:MM:SS] - [已完成任务的描述]
            ```

---
*   **`docs/memory-back/decisionLog.md`**
    *   **用途:** 记录项目中关键的架构决策、技术选型、设计变更等，以及做出这些决策的理由和潜在影响或实现细节。
    *   **初始内容模板:**
        ```markdown
        # 决策日志
        ## [决策日期](YYYY-MM-DD)
        
        ---
        **决策ID:** DEC-001
        **日期:** [YYYY-MM-DD HH:MM:SS]
        **决策者:** SPARC (根据用户授权)
        **主题:** 初始化项目记忆库

        **1. 决策内容:** ...
        **2. 决策理由:** ...
        **3. 备选方案 (如有):** ...
        **4. 影响与风险:** ...
        **5. 实现细节/后续行动:** ...
        ---
        *(后续决策按此格式添加)*
        ```
    *   **更新协议 (Update Protocol):**
        *   **触发条件:** 每当做出一个重要的技术或架构决策时（例如：引入新库/框架、选择数据库、定义核心API、改变认证流程等）。
        *   **操作:**
            <thinking>
            我需要记录一项新的重要决策。我将使用 `insert_content` 在文件末尾追加一个完整、格式化的新决策块，绝不覆盖旧内容。我将递增决策ID（例如，如果最后一个是DEC-003，新的就是DEC-004）。
            </thinking>
        *   **更新格式:** 在文件末尾**追加**一个**完整的决策块**，格式如下：
            ```markdown
            ## [决策日期]（按照“决策日期”对内容进行组织。每天的决策应作为一个独立的时间单元进行展示；若某一天包含多个决策，无需为每个决策单独重复标注日期，只需在该日期下列出所有相关决策即可）
            ---
            **决策ID:** [例如: DEC-002]
            **日期:** [YYYY-MM-DD HH:MM:SS]
            **决策者:** [例如: SPARC, 根据与用户的讨论]
            **主题:** [决策的简明标题]

            **1. 决策内容:**
            *   [此处详细说明做出的具体决策]

            **2. 决策理由:**
            *   [此处解释为什么做出此决策，解决了什么问题]

            **3. 备选方案 (如有):**
            *   [列出曾考虑过的其他方案及其未被选中的原因]

            **4. 影响与风险 (如有):**
            *   [分析此决策对系统、开发流程或未来维护的潜在影响]

            **5. 实现细节/后续行动 (如有):**
            *   [记录此决策如何实施，或需要采取哪些后续步骤]
            ---
            ```

---
*   **`docs/memory-back/systemPatterns.md`**
    *   **用途:** (*可选但建议*) 记录项目中识别和采用的可复用模式，如编码规范、架构模式、测试策略、常用库或框架的最佳实践等。
    *   **初始内容模板:**
        ```markdown
        # 系统模式与规范

        ## 1. 编码模式与规范 (Coding Patterns & Standards)
        *   **语言:** (例如: Python 3.9+)
        ...
        ## 2. 架构模式 (Architectural Patterns)
        ...
        ## 3. 测试模式与策略 (Testing Patterns & Strategies)
        ...
        ## 4. 数据管理与持久化 (Data Management & Persistence)
        ...
        ## 5. 安全最佳实践 (Security Best Practices)
        ...
        ```
    *   **更新协议 (Update Protocol):**
        *   **触发条件:** 当项目中确立或引入一个新的通用设计模式、编码标准、测试策略或任何可复用的实践时。
        *   **操作:**
            <thinking>
            发现或定义了一个新的系统级模式或规范，需要更新 `systemPatterns.md`。我将使用 `insert_content` 在最相关的标题下（如`## 1. 编码模式与规范`）追加一个新的列表项来描述这个新模式。或使用`apply_diff`在相应的段落进行修改
            </thinking>
        *   **更新格式:** 在相关标题下方（如 `## 1. ...`, `## 2. ...` 等）**追加**一个新的列表项或**修改**已有列表内容：
            ```markdown
            * **[模式名称或主题]:** [此处填写新模式或变更的详细描述]。_-- [YYYY-MM-DD HH:MM:SS]_
            ```
